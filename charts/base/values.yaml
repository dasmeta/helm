# Default values for datalertio.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is  the chart appVersion.
  tag: 1.21

# Init containers
# initContainers:
#   - name: config
#     args:
#     - /config.json
#     - /test/config.json
#     secrets:
#       - CLIENT_ID:
#           from: client-market
#           key: client_id
#       - AUTH_TOKEN:
#           from: auth-token
#           key: token
#     image:
#       repository: nginx
#       pullPolicy: IfNotPresent
#       tag: latest
#     volumes:
#       - mountPath: /config.json
#         name: config-json
#         subPath: config.json

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

job:
  serviceAccount:
    create: false
    annotations: {}

podAnnotations: {}

podSecurityContext: {}
# fsGroup: 2000

securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
# runAsUser: 1000

service:
  enabled: true
  name: http
  type: NodePort
  port: 80
  protocol: TCP
  extraPorts: []
  ## here is sample how you can set/enable additional ports on service
  # extraPorts:
  #   - port: 8080
  #     targetPort: 8080
  #     protocol: TCP
  #     name: http-second

# The ingress class setting by annotation is deprecated and we have setIngressClassByField option for backward compatibility for now, check doc here https://kubernetes.io/docs/concepts/services-networking/ingress/#deprecated-annotation
# have 'setIngressClassByField: true' to set ingress class by spec.ingressClassName,
# we seems cant have both "kubernetes.io/ingress.class" and spec.ingressClassName set at once, so there is check(for alb, application-gateway and cce the check is missing for now) to not set annotation if we set ingress class fy field
# TODO: have ingress class setting by field used always and remove deprecated "kubernetes.io/ingress.class" annotations
setIngressClassByField: false

# it allows also to pass list of ingresses in following form
# NOTE: in case of list it will auto attach uniq identify numbers to ingress names starting from second item, you can use nameSuffix field to set custom suffix instead of number
ingress:
  enabled: false
  class: alb
  annotations: {}
  hosts:
    - host: host.name.com
      paths:
        - path: /*
          backend:
            serviceName: ssl-redirect
            servicePort: use-annotation
        - backend:
            serviceName: base
            servicePort: 80
          path: /*
  tls: []
# example how can be ingress list passed
# ingress:
#   - class: nginx
#     hosts:
#       - host: host.name.com
#         paths:
#           - backend:
#               serviceName: base
#               servicePort: 80
#             path: /*
#   - class: nginx-second
#     nameSuffix: -second
#     hosts:
#       - host: host-second.name.com
#         paths:
#           - path: /*
#             backend:
#               serviceName: base
#               servicePort: 8080

secrets: []
secretsDefaultEngine: "ExternalSecrets"
# secrets:
#   - external-secret-1
#   - external-secret-2
#   - external-secret-3
#   - external-secret-4
#   - DATABASE:
#       from: helm-test-secret
#       key: database
#   - ENDPOINT:
#       from: helm-test-secret
#       key: endpoint
#   - PASSWORD:
#       from: helm-test-secret
#       key: password
#   - SPRING_DATASOURCE_URL:
#       from: helm-test-secret
#       key: spring_datasource_url
#   - USERNAME:
#       from: helm-test-secret
#       key: username

extraContainer: {}

resources:
  {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
#   memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

config: {}

containerPort: 80

livenessProbe:
  {}
  # failureThreshold: 3
  # httpGet:
  #   path: /
  #   port: 80
  #   scheme: HTTP
  # initialDelaySeconds: 60
  # periodSeconds: 5
  # successThreshold: 1
# timeoutSeconds: 1

readinessProbe:
  {}
  # httpGet:
  #   path: /
  #   port: http
  # initialDelaySeconds: 60
# periodSeconds: 5

envFrom:
  secret:

startupProbe:
  {}
  # httpGet:
  #   path: /
#   port: http

storage:
  {}
  # - persistentVolumeClaimName: "pvc-1"
  #   accessModes:
  #     - ReadWriteMany
  #   className: efs-sc
  #   requestedSize: 2Gi
  #   enableDataSource: false
  # - persistentVolumeClaimName: pvc-2
  #   accessModes:
  #     - ReadWriteMany
  #   className: efs-sc-root
  #   requestedSize: "2Gi"
  #   enableDataSource: false

deployment: {}

env: dev
product: application

pdb:
  enabled: false
  minAvailable: 1
  pdbName:

serviceMonitor:
  enabled: false
  interval: 30s
  targetPort: 80
  path: /metrics

# This config allows to enable custom rollout strategies by using different providers/operators
# right now only flagger (https://flagger.app/) operator supported and tested for canary with nginx
## NOTE for flagger operator:
## - flagger supports several service meshes and ingresses as provider for traffic splitting, and by default we have using nginx here, so you have to check docs and have at least one used for you app
## - you need to have flagger tool/operator already installed to be able to use its crd, this can be done by installing flagger helm https://artifacthub.io/packages/helm/flagger/flagger
## - also there is need to have at least one metric server/provider enabled(it supports) like prometheus as it uses metrics for checking success rates, the flagger helm allows to install prometheus
## - with flagger enabled we disable native kubernetes service as flagger creates/overrides this service
## - with separate installed prometheus operator(not one that comes with flagger helm) the default `request-success-rate` and `request-duration` metrics templates may not work so you may need to create custom metric templates, the canary+nginx+prometheus metric template can be created by using `dasmeta/flagger-metric-template` chart
rolloutStrategy:
  enabled: false
  operator: flagger
  configs: {}
  # here are all supported flagger configs
  # configs:
  #   provider: nginx # the flagger ingress/service-mesh provider (default nginx)
  #   progressDeadlineSeconds: 61 # the maximum time in seconds for the canary deployment to make progress before it is rollback (default 600s)
  #   canaryReadyThreshold: 51 # minimum percentage of canary pods that must be ready before considering canary ready for traffic shifting (default 100)
  #   primaryReadyThreshold: 51 # minimum percentage of primary pods that must be ready before considering primary ready for traffic shifting (default 100)
  #   interval: 11s # schedule interval (default 60s)
  #   threshold: 11 # max number of failed metric checks before rollback (default 10)
  #   maxWeight: 31 # max traffic percentage (0-100) routed to canary (default 30)
  #   stepWeight: 11 # canary increment step percentage (0-100) (default 10)
  #   # min and max replicas count for primary hpa, default to main app hpa, the main app hpa values also being used for canary deploy hpa so we use this options to have custom values for primary hpa
  #   primaryScalerMinReplicas: 3
  #   primaryScalerMaxReplicas: 7
  #   metrics: # metrics template configs to use for identifying if canary deploy handles request normally, the `request-success-rate` and `request-duration` named ones are available by default, and you can create custom metric templates
  #     - name: request-success-rate
  #       # minimum req success rate (non 5xx responses) percentage (0-100)
  #       thresholdRange:
  #         min: 99
  #       interval: 1m
  #     - name: request-duration
  #       # maximum req duration P99, milliseconds
  #       thresholdRange:
  #         max: 500
  #       interval: 1m
  #     # - name: request-success-rate-nginx-custom
  #     #   interval: 1m
  #     #   templateRef:
  #     #     name: request-success-rate-nginx-custom
  #     #     namespace: ingress-nginx
  #     #   # minimum req success rate (non 5xx responses) percentage (0-100)
  #     #   thresholdRange:
  #     #     min: 99
  #     # - name: request-duration-nginx-custom
  #     #   interval: 1m
  #     #   templateRef:
  #     #     name: request-duration-nginx-custom
  #     #     namespace: ingress-nginx
  #     #   # maximum req duration P99, milliseconds
  #     #   thresholdRange:
  #     #     max: 500
  #   webhooks: # (optional) webhooks can be used for load testing before traffic switching to canaries by using `pre-rollout` type and also generating traffic
  #     - name: acceptance-test
  #       type: pre-rollout
  #       url: http://flagger-loadtester.localhost/
  #       timeout: 30s
  #       metadata:
  #         type: bash
  #         cmd: "curl -sd 'test' http://http-echo-canary/ping | grep ping"
  #     - name: load-test
  #       url: http://flagger-loadtester.localhost/
  #       timeout: 5s
  #       metadata:
  #         cmd: "hey -z 1m -q 3 -c 1 http://http-echo.localhost/ping"
  #   alerts: # (optional) alerts allow to setup custom alerting/notify based on flaggers alert provider crd(there is also option to set global alert config with flagger), for more info look https://docs.flagger.app/usage/alerting
  #     - name: "on-call Slack"
  #       severity: error
  #       providerRef:
  #         name: on-call
  #         namespace: ingress-nginx
